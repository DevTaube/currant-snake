/*
 * Copyright 2023 DevTaube
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
class CurrantPreprocessor{constructor(){this.macros=[]}createMacroObject(e,t){return{regex:e,replacement:t}}process(e){let t="#start-macro",r="#end-macro",n=e.split("\n"),a=null,s="";for(const e of n){let n=e.trim();null!==a?n.startsWith(r)?(this.macros.push(this.createMacroObject(a,s.substring(0,s.length-1))),a=null,s=""):s+=e+"\n":n.startsWith(t)&&(a=new RegExp(n.substring(t.length+1),"gm"))}let u="",o=!1;for(const e of n){let n=e.trim();n.startsWith(t)&&(o=!0),o&&(u+="\n"),o||(u+=e+"\n"),n.startsWith(r)&&(o=!1)}u=u.split(/\/\/.*$/gm).join("");let i=/\/\*((?!\*\/).)*\*\//ms;for(;;){let e=i.exec(u);if(null==e)break;let t=u.substring(0,e.index),r=u.substring(e.index+e[0].length),n="";for(let t=0;t<(e[0].match(/\n/g)||[]).length;t++)n+="\n";u=t+n+r}for(const e of this.macros)for(;;){let t=e.regex.exec(u);if(null===t)break;let r=e.replacement.slice(0,e.replacement.length),n=new RegExp("{\\d+}");for(;;){let e=n.exec(r);if(null===e)break;r=r.slice(0,e.index)+t[Number(e[0].slice(1,2))+1]+r.slice(e.index+e[0].length,r.length)}let a=r.split("\n");for(let e=0;e<a.length;e++)a[e]=a[e].trim();r=a.join(" "),u=u.slice(0,t.index)+r+u.slice(t.index+t[0].length,u.length)}return u}}class CurrantLexer{constructor(){this.presets=[this.createPreset("\\d+u8","u8_literal"),this.createPreset("\\d+u16","u16_literal"),this.createPreset("\\d+u32","u32_literal"),this.createPreset("\\d+u64","u64_literal"),this.createPreset("-?\\d+i8","i8_literal"),this.createPreset("-?\\d+i16","i16_literal"),this.createPreset("-?\\d+i32","i32_literal"),this.createPreset("-?\\d+i64","i64_literal"),this.createPreset("-?\\d+(\\.\\d+)?f32","f32_literal"),this.createPreset("-?\\d+(\\.\\d+)?f64","f64_literal"),this.createPreset("true","boolean_literal"),this.createPreset("false","boolean_literal"),this.createPreset('(?<!\\\\)".*?(?<!\\\\)"',"string_literal"),this.createPreset("\\/\\/","line_comment"),this.createPreset("\\/\\*","block_comment_start"),this.createPreset("\\*\\/","block_comment_end"),this.createPreset(";","line_terminator"),this.createPreset("\\(","opening_parenthesis"),this.createPreset("\\)","closing_parenthesis"),this.createPreset("\\[","opening_bracket"),this.createPreset("\\]","closing_bracket"),this.createPreset("{","opening_brace"),this.createPreset("}","closing_brace"),this.createPreset("=","equals"),this.createPreset("\\+","plus"),this.createPreset("-","minus"),this.createPreset("\\*","asterisk"),this.createPreset("\\/","slash"),this.createPreset("%","percent"),this.createPreset("&","ampersand"),this.createPreset("!","exclamation_mark"),this.createPreset("\\.","dot"),this.createPreset("<","smaller"),this.createPreset(">","greater"),this.createPreset(",","comma"),this.createPreset(":","colon"),this.createPreset("@","at"),this.createPreset("#","hashtag"),this.createPreset("~","tilde"),this.createPreset("\\?","question_mark"),this.createPreset("\\$","dollar"),this.createPreset("&&","double_ampersand"),this.createPreset("\\|\\|","double_pipe"),this.createPreset("==","double_equals"),this.createPreset("!=","not_equals"),this.createPreset("<=","smaller_equals"),this.createPreset(">=","greater_equals"),this.createPreset("<-","arrow_left"),this.createPreset("->","arrow_right"),this.createPreset("=>","double_arrow_right"),this.createPreset("\\w+","identifier")]}createPreset(e,t){return{name:t,pattern:new RegExp(e,"g")}}tokenize(e,t){let r=[];for(const n of this.presets){let a;for(;null!=(a=n.pattern.exec(e));){let e={index:a.index,length:a[0].length,name:n.name,text:a[0],file:t};r.push(e)}}r.sort(((e,t)=>e.index-t.index));let n=[],a=new Array(r.length);for(let e=0;e<a.length;e++)a[e]=!1;let s=[];for(const e of r)n.push({index:e.index,active:!0,token:e}),n.push({index:e.index+e.text.length,active:!1,token:e});n.sort(((e,t)=>e.index-t.index));for(const e of n){if(e.active)for(let t=0;t<a.length;t++)a[t]&&s.push([e.token,r[t]]);a[r.indexOf(e.token)]=e.active}let u=[];for(const e of s){let t=0;u.includes(e[0])||(u.includes(e[1])||(e[0].length>e[1].length?t=1:e[0].length<e[1].length||"identifier"===e[0].name?t=0:"identifier"===e[1].name&&(t=1),u.push(e[t])))}for(const e of u)r.splice(r.indexOf(e),1);for(const t of r)t.line=(e.substring(0,t.index).match(/\n/g)||[]).length+1,delete t.index,delete t.length;return r}}function currantCompareTypes(e,t){return e instanceof CurrantCustomType&&t instanceof CurrantCustomType?e.constructorFunction.file===t.constructorFunction.file&&e.constructorFunction.line===t.constructorFunction.line&&e.constructorFunction.src===t.constructorFunction.src:e.constructor===t.constructor}function currantCreateDoNumCheck(e){if("number"!=typeof e&&"bigint"!=typeof e)throw new Error("tried to create Currant number type instance from something that is not a number")}function currantCreateU8(e){return currantCreateDoNumCheck(e),(new CurrantU8Type).fromValue(Number(e))}function currantCreateU16(e){return currantCreateDoNumCheck(e),(new CurrantU16Type).fromValue(Number(e))}function currantCreateU32(e){return currantCreateDoNumCheck(e),(new CurrantU32Type).fromValue(Number(e))}function currantCreateU64(e){return currantCreateDoNumCheck(e),(new CurrantU64Type).fromValue(BigInt(Number(e)))}function currantCreateI8(e){return currantCreateDoNumCheck(e),(new CurrantI8Type).fromValue(Number(e))}function currantCreateI16(e){return currantCreateDoNumCheck(e),(new CurrantI16Type).fromValue(Number(e))}function currantCreateI32(e){return currantCreateDoNumCheck(e),(new CurrantI32Type).fromValue(Number(e))}function currantCreateI64(e){return currantCreateDoNumCheck(e),(new CurrantI64Type).fromValue(BigInt(Number(e)))}function currantCreateF32(e){return currantCreateDoNumCheck(e),(new CurrantF32Type).fromValue(Number(e))}function currantCreateF64(e){return currantCreateDoNumCheck(e),(new CurrantF64Type).fromValue(Number(e))}function currantCreateBool(e){if("boolean"!=typeof e)throw new Error("tried to create Currant boolean type instance from something that is not a boolean");return(new CurrantBooleanType).fromValue(e)}function currantCreateFun(e){if("function"!=typeof e)throw new Error("tried to create Currant function type instance from something that is not a function");return(new CurrantFunctionType).fromValue(new CurrantJsFunction(e))}function currantCreateArray(e){if(e.constructor!==Array)throw new Error("tried to create Currant array type instance from something that is not an array");return(new CurrantArrayType).fromValue(new CurrantArray(e))}function currantCreateStr(e){if("string"!=typeof e)throw new Error("tried to create Currant str type instance from something that is not a string");return(new CurrantStringType).fromValue(e)}class CurrantNodeParseError extends Error{constructor(){super("Unable to parse node")}}class CurrantNode{static get EVAL_NODES(){return[CurrantVariableGetNode,CurrantPointerDerefNode,CurrantFunctionCallNode,CurrantArrayAccessNode,CurrantU8Node,CurrantU16Node,CurrantU32Node,CurrantU64Node,CurrantI8Node,CurrantI16Node,CurrantI32Node,CurrantI64Node,CurrantF32Node,CurrantF64Node,CurrantBooleanNode,CurrantStringNode,CurrantMemberAccessNode,CurrantJsReferenceNode,CurrantMemberPointerNode,CurrantPointerNode,CurrantFunctionNode,CurrantArrayNode,CurrantGetType,CurrantCastNumberNode,CurrantParenthesesNode,CurrantNegateBooleanNode,CurrantMultiplicativeNode,CurrantAdditiveNode,CurrantRelationalNode,CurrantEqualityNode,CurrantLogicalAndNode,CurrantLogicalOrNode,CurrantVariableSetNode,CurrantVariableCreateNode,CurrantReturnNode].reverse()}static get SCOPE_OPERATORS(){return[["{","}"],["(",")"],["[","]"]]}constructor(e){if(this.name=e,this.block=null,this.invalidOnScopeMismatch=!1,"function"!=typeof this.doParse)throw new Error(`"${this.constructor.name}" does not implement 'doParse()'`);if("function"!=typeof this.doExecute)throw new Error(`"${this.constructor.name}" does not implement 'doExecute()'`)}copy(e){let t=new this.constructor;for(const e of Object.keys(this))t[e]=this[e];t.block=e,t.children=[];let r=e;t instanceof CurrantBlockNode&&(r=t);for(let e=0;e<this.children.length;e++)null===this.children[e]?t.addChild(null):t.addChild(this.children[e].copy(r));return"function"==typeof t.afterCopy&&t.afterCopy(this),t}disableScopeMismatchErrors(e){return this.invalidOnScopeMismatch=!0===e,this}parse(e){this.tokens=e,this.tokenIndex=0,this.children=[],this.line=null,this.file=null,this.tokens.length>0&&(this.line=this.tokens[0].line,this.file=this.tokens[0].file,this.tokens[0].currant.currentLine=this.line,this.tokens[0].currant.currentFile=this.file),this.doParse(),this.src="";for(const e of this.tokens)this.src+=e.text;return delete this.tokens,delete this.tokenIndex,this}parseInvalid(){throw new CurrantNodeParseError}checkTokenInBounds(){(this.tokenIndex<0||this.tokenIndex>=this.tokens.length)&&this.parseInvalid()}token(){return this.checkTokenInBounds(),this.tokens[this.tokenIndex]}expectToken(e){this.checkTokenInBounds(),this.token().name!==e&&this.parseInvalid()}nextToken(){this.checkTokenInBounds(),this.tokenIndex++,this.checkTokenInBounds()}hasNextToken(){return this.tokenIndex+1<this.tokens.length}evalUntilLast(e,t){0===this.tokens.length&&this.parseInvalid();let r=this.tokenIndex,n=new Array(CurrantNode.SCOPE_OPERATORS.length).fill(0),a=-1;try{for(let t=r;t<this.tokens.length;t++){let r=this._getAtBaseScopes(n);e.includes(this.tokens[t].name)&&r&&(a=t);for(let e=0;e<CurrantNode.SCOPE_OPERATORS.length;e++){const r=CurrantNode.SCOPE_OPERATORS[e];this.tokens[t].text===r[0]&&n[e]++,this.tokens[t].text===r[1]&&n[e]--}}}catch(e){if(!(e instanceof CurrantNodeParseError))throw e;for(let e=0;e<CurrantNode.SCOPE_OPERATORS.length;e++){const r=CurrantNode.SCOPE_OPERATORS[e],a=n[e];if(0!==a){if(a>0&&!1===t&&!1===this.invalidOnScopeMismatch)throw new Error(`Opened scope using "${r[0]}", but never closed it using "${r[1]}"`);if(a<0&&!1===t&&!1===this.invalidOnScopeMismatch)throw new Error(`Closed scope using "${r[1]}", but never opened it using "${r[0]}"`);!0!==t&&!0!==this.invalidOnScopeMismatch||this.parseInvalid()}}throw e}return-1===a&&this.parseInvalid(),this.tokenIndex=a,this.evalTokens(this.tokens.slice(r,a),!1,!0)}evalUntilLastScopeOpen(e,t){let r=this.tokenIndex,n=0,a=-1;for(let s=r;s<this.tokens.length;s++)this.tokens[s].name===e&&0===n&&(a=s),this.tokens[s].name===e&&n++,this.tokens[s].name===t&&n--;return-1===a&&this.parseInvalid(),this.tokenIndex=a,this.evalTokens(this.tokens.slice(r,a),!1,!0)}evalUntil(e,t,r){let n=null==e;n&&(e=["line_terminator"]);let a=new Array(CurrantNode.SCOPE_OPERATORS.length).fill(0),s=[];0===this.tokens.length&&this.parseInvalid();try{for(;;){let t=this._getAtBaseScopes(a);if(t&&s.length>0&&e.includes(this.token().name))break;for(let e=0;e<CurrantNode.SCOPE_OPERATORS.length;e++){const t=CurrantNode.SCOPE_OPERATORS[e];this.token().text===t[0]&&a[e]++,this.token().text===t[1]&&a[e]--}if(t=this._getAtBaseScopes(a),s.push(this.token()),t&&s.length>0&&n&&!this.hasNextToken())break;this.nextToken()}}catch(e){if(!(e instanceof CurrantNodeParseError))throw e;for(let e=0;e<CurrantNode.SCOPE_OPERATORS.length;e++){const t=CurrantNode.SCOPE_OPERATORS[e],n=a[e];if(0!==n){if(n>0&&!1===r&&!1===this.invalidOnScopeMismatch)throw new Error(`Opened scope using "${t[0]}", but never closed it using "${t[1]}"`);if(n<0&&!1===r&&!1===this.invalidOnScopeMismatch)throw new Error(`Closed scope using "${t[1]}", but never opened it using "${t[0]}"`);!0!==r&&!0!==this.invalidOnScopeMismatch||this.parseInvalid()}}throw e}return this.evalTokens(s,t,!1)}evalTokens(e,t,r){for(const t of CurrantNode.EVAL_NODES)try{return(new t).disableScopeMismatchErrors(!0===r).parse(e)}catch(e){if(!(e instanceof CurrantNodeParseError))throw e}if(!0===t)throw new Error("Syntax Error");this.parseInvalid()}_getAtBaseScopes(e){for(const t of e)if(!(t<=0))return!1;return!0}expectEnd(){this.hasNextToken()&&this.parseInvalid()}addChild(e){if(this.children.push(e),null===e)return;let t=this.block;this instanceof CurrantBlockNode&&(t=this),e.setBlock(t)}setBlock(e){if(this.block=e,this instanceof CurrantBlockNode)null!==e&&this.setRuntime(e.currant);else for(const t of this.children)null!==t&&t.setBlock(e)}childValue(e){return null===this.childValues[e]?null:this.childValues[e]instanceof CurrantVariableReference?this.childValues[e].get():this.childValues[e]}execute(){this.block.currant.currentLine=this.line,this.block.currant.currentFile=this.file,this.executeChildren=!0,"function"==typeof this.prepareExecute&&this.prepareExecute(),this.childValues=new Array(this.children.length);for(let e=0;e<this.children.length&&this.executeChildren;e++)null===this.children[e]?this.childValues[e]=null:this.childValues[e]=this.children[e].execute();return this.doExecute()}}class CurrantBlockNode extends CurrantNode{constructor(){super("block"),this.returnable=!0,this.currant=null}afterCopy(e){const t=this.variables;if(this.variables=new Map,void 0!==t)for(const r of t.keys()){this.variables.set(r,new CurrantBlockVariableWrapperObject(t.get(r).get().copy()));const n=this.variables.get(r).get().get();null!==n&&n instanceof CurrantFunction&&n.body.block===e&&(n.body.block=this)}}setRuntime(e){return this.currant=e,this}afterBlock(){null!==this.block&&this.setRuntime(this.block.currant)}setReturnable(e){return this.returnable=e,this}doParse(){if(0!==this.tokens.length){for(;;)if("line_terminator"!==super.token().name){if(super.addChild(super.evalUntil(null,!0,!1)),!super.hasNextToken())break;super.expectToken("line_terminator"),super.nextToken()}else{if(!super.hasNextToken())break;super.nextToken()}super.expectEnd()}}returnValue(e){this.returnable?this.returnedValue=e:(this.returnedValue=null,this.block.returnValue(e)),this.executeChildren=!1}setAfterPrepare(e){this.afterPrepare=e}execute(){this.executeChildren=!0,this.prepareExecute(),this.childValues=new Array(this.children.length);for(let e=0;e<this.children.length&&this.executeChildren;e++)this.childValues[e]=this.children[e].execute();return this.doExecute()}prepareExecute(){this.returnedValue=null,this.variables=new Map,void 0!==this.afterPrepare&&this.afterPrepare(),this.afterPrepare=void 0}doExecute(){return null===this.returnedValue?(new CurrantNothingType).fromNode(null):this.returnedValue}static staticHasVariable(e,t,r){let n=!1;return null!==t&&(n=CurrantBlockNode.staticHasVariable(t.variables,t.block,r)),e.has(r)||n}hasVariable(e){return CurrantBlockNode.staticHasVariable(this.variables,this.block,e)}static staticGetVariableWrapper(e,t,r){if(!e.has(r)&&null!==t)return CurrantBlockNode.staticGetVariableWrapper(t.variables,t.block,r);if(!e.has(r))throw new Error(`unable to access variable - "${r}" is not a variable known by this scope`);return e.get(r)}static staticGetVariable(e,t,r){return CurrantBlockNode.staticGetVariableWrapper(e,t,r).get()}getVariable(e){return CurrantBlockNode.staticGetVariable(this.variables,this.block,e)}static staticGetVariableRef(e,t,r){return new CurrantVariableReference((n=>{CurrantBlockNode.staticSetVariable(e,t,r,n)}),(()=>CurrantBlockNode.staticGetVariable(e,t,r)))}getVariableRef(e){return CurrantBlockNode.staticGetVariableRef(this.variables,this.block,e)}static staticSetVariable(e,t,r,n){e.has(r)?e.get(r).value=n:CurrantBlockNode.staticHasVariable(e,t,r)?CurrantBlockNode.staticSetVariable(t.variables,t.block,r,n):e.set(r,new CurrantBlockVariableWrapperObject(n))}setVariable(e,t){CurrantBlockNode.staticSetVariable(this.variables,this.block,e,t)}static staticCreateVariable(e,t,r,n){if(e.has(r))throw new Error(`unable to create variable - variable "${r}" already exists in this scope`);e.set(r,new CurrantBlockVariableWrapperObject(n))}createVariable(e,t){CurrantBlockNode.staticCreateVariable(this.variables,this.block,e,t)}}class CurrantBlockVariableWrapperObject{constructor(e){this.value=e}get(){return this.value}}class CurrantLiteralNode extends CurrantNode{constructor(e,t,r){super(e),this.tokenName=t,this.literalType=r}doParse(){super.expectToken(this.tokenName),this.value=super.token().text,super.expectEnd()}doExecute(){return(new this.literalType).fromNode(this)}}class CurrantVariableCreateNode extends CurrantNode{constructor(){super("variable-create")}doParse(){super.expectToken("identifier"),this.varName=super.token().text,super.nextToken(),super.expectToken("colon"),super.nextToken(),"question_mark"===super.token().name?(super.addChild(null),super.nextToken()):super.addChild(super.evalUntil(["equals"],!1,!1)),super.expectToken("equals"),super.nextToken(),super.addChild(super.evalUntil(null,!1,!1)),super.expectEnd()}doExecute(){let e=this.childValue(0);if(e=null===e?this.childValue(1).type:e.get(),!(e instanceof CurrantType))throw new Error(`unable to create variable - "${this.children[0].src}" is not a type`);if(!currantCompareTypes(e,this.childValue(1).type))throw new Error(`unable to create variable - "${this.children[1].src}" is not of type "${this.children[0].src}"`);return this.block.createVariable(this.varName,this.childValue(1).copy()),this.block.getVariableRef(this.varName)}}class CurrantVariableSetNode extends CurrantNode{constructor(){super("variable-set")}doParse(){super.addChild(super.evalUntil(["equals"],!1,!1)),super.expectToken("equals"),super.nextToken(),super.addChild(super.evalUntil(null,!1,!1)),super.expectEnd()}doExecute(){if(!(this.childValues[0]instanceof CurrantVariableReference))throw new Error(`unable to set variable - "${this.children[0].src}" is not a variable`);if(!currantCompareTypes(this.childValue(0).type,this.childValue(1).type))throw new Error(`unable to set variable - "${this.children[1].src}" does not have the correct type for "${this.children[0].src}"`);return this.childValues[0].set(this.childValue(1).copy()),this.childValues[0]}}class CurrantVariableGetNode extends CurrantLiteralNode{constructor(){super("variable-get","identifier")}doExecute(){return this.block.getVariableRef(this.value)}}class CurrantJsReferenceNode extends CurrantNode{constructor(){super("js-reference")}doParse(){super.expectToken("identifier"),"t"!==super.token().text&&"f"!==super.token().text&&super.parseInvalid(),this.refType=super.token().text,super.nextToken(),super.expectToken("at"),super.nextToken(),super.expectToken("identifier"),this.refName=super.token().text,super.expectEnd()}doExecute(){switch(this.refType){case"t":return this._executeClassRef();case"f":return this._executeFunctionRef()}}_executeClassRef(){try{let typeInstance=eval(`new ${this.refName}()`);if(!(typeInstance instanceof CurrantType))throw new ReferenceError;return(new CurrantTypeType).fromValue(typeInstance)}catch(e){if(!(e instanceof ReferenceError))throw e;throw new Error(`"t@${this.refName}" does not refer to a known Javascript class that extends 'CurrantType'.`)}}_executeFunctionRef(){try{let functionReference=eval(`${this.refName}`);if("function"!=typeof functionReference)throw new ReferenceError;return currantCreateFun(functionReference)}catch(e){if(!(e instanceof ReferenceError))throw e;throw new Error(`"f@${this.refName}" does not refer to a known Javascript function.`)}}}class CurrantNegateBooleanNode extends CurrantNode{constructor(){super("negate-bool")}doParse(){super.expectToken("exclamation_mark"),super.nextToken(),super.addChild(super.evalUntil(null,!1,!1)),super.expectEnd()}doExecute(){let e=super.childValue(0);if("boolean"!=typeof e.get())throw new Error(`failed to negate value - "${this.children[0].src}" is not a boolean`);return e.type.fromValue(!e.get())}}class CurrantLogicalAndNode extends CurrantNode{constructor(){super("logical-and")}doParse(){super.addChild(super.evalUntil(["double_ampersand"],!1,!1)),super.expectToken("double_ampersand"),super.nextToken(),super.addChild(super.evalUntil(null,!1,!1)),super.expectEnd()}doExecute(){let e=super.childValue(0).get();if("boolean"!=typeof e)throw new Error(`failed to compute logical AND - "${this.children[0].src}" is not a boolean`);let t=super.childValue(1).get();if("boolean"!=typeof t)throw new Error(`failed to compute logical AND - "${this.children[1].src}" is not a boolean`);return super.childValue(0).type.fromValue(e&&t)}}class CurrantLogicalOrNode extends CurrantNode{constructor(){super("logical-or")}doParse(){super.addChild(super.evalUntil(["double_pipe"],!1,!1)),super.expectToken("double_pipe"),super.nextToken(),super.addChild(super.evalUntil(null,!1,!1)),super.expectEnd()}doExecute(){let e=super.childValue(0).get();if("boolean"!=typeof e)throw new Error(`failed to compute logical OR - "${this.children[0].src}" is not a boolean`);let t=super.childValue(1).get();if("boolean"!=typeof t)throw new Error(`failed to compute logical OR - "${this.children[1].src}" is not a boolean`);return super.childValue(0).type.fromValue(e||t)}}function currantGetNumberTypes(){return[CurrantI8Type,CurrantI16Type,CurrantI32Type,CurrantI64Type,CurrantU8Type,CurrantU16Type,CurrantU32Type,CurrantU64Type,CurrantF32Type,CurrantF64Type]}class CurrantCastNumberNode extends CurrantNode{constructor(){super("cast-number")}doParse(){super.addChild(super.evalUntil(["tilde"],!1,!1)),super.expectToken("tilde"),super.nextToken(),super.addChild(super.evalUntil(null,!1,!1)),super.expectEnd()}doExecute(){let e=super.childValue(0).get(),t=super.childValue(1).get(),r=super.childValue(1).type;if(!currantGetNumberTypes().includes(r.constructor))throw new Error(`failed to cast between number types - "${this.children[1].src}" is not a number`);if(!currantGetNumberTypes().includes(e.constructor))throw new Error(`failed to cast between number types - "${this.children[0].src}" is not a number type`);let n=r.constructor===CurrantI64Type||r.constructor===CurrantU64Type,a=e.constructor===CurrantI64Type||e.constructor===CurrantU64Type;return n&&!a&&(t=Number(t)),!n&&a&&(t=BigInt(Math.floor(t))),e.fromValue(t)}}class CurrantAdditiveNode extends CurrantNode{constructor(){super("additive")}doParse(){super.addChild(super.evalUntilLast(["plus","minus"],!0)),this.operation=super.token().text,super.nextToken(),super.addChild(super.evalUntil(null,!1,!1)),super.expectEnd()}doExecute(){if(!currantCompareTypes(super.childValue(0).type,super.childValue(1).type))throw new Error(`unable to do arithmetic operation (or string concatenation) - "${this.children[0].src}" and "${this.children[1].src}" do not have the same type`);if(!currantGetNumberTypes().includes(super.childValue(0).type.constructor)&&super.childValue(0).type.constructor!==CurrantStringType)throw new Error(`unable to do arithmetic operation (or string concatenation) - "${this.children[0].src}" is not a number or string`);if("+"!==this.operation&&super.childValue(0).type.constructor===CurrantStringType)throw new Error(`unable to do arithmetic operation - "${this.children[0].src}" is not a number`);let e=super.childValue(0).type.varStorage(1);switch(this.operation){case"+":e[0]=super.childValue(0).get()+super.childValue(1).get();break;case"-":e[0]=super.childValue(0).get()-super.childValue(1).get()}return new CurrantTypeInstance(super.childValue(0).type,e)}}class CurrantMultiplicativeNode extends CurrantNode{constructor(){super("multiplicative")}doParse(){super.addChild(super.evalUntilLast(["asterisk","slash","percent"],!0)),this.operation=super.token().text,super.nextToken(),super.addChild(super.evalUntil(null,!1,!1)),super.expectEnd()}doExecute(){if(!currantCompareTypes(super.childValue(0).type,super.childValue(1).type))throw new Error(`unable to do arithmetic operation - "${this.children[0].src}" and "${this.children[1].src}" do not have the same type`);if(!currantGetNumberTypes().includes(super.childValue(0).type.constructor))throw new Error(`unable to do arithmetic operation - "${this.children[0].src}" is not a number`);let e=super.childValue(0).type.varStorage(1);switch(this.operation){case"*":e[0]=super.childValue(0).get()*super.childValue(1).get();break;case"/":e[0]=super.childValue(0).get()/super.childValue(1).get();break;case"%":e[0]=super.childValue(0).get()%super.childValue(1).get()}return new CurrantTypeInstance(super.childValue(0).type,e)}}class CurrantRelationalNode extends CurrantNode{constructor(){super("relational")}doParse(){super.addChild(super.evalUntil(["smaller","greater","smaller_equals","greater_equals"],!1,!1)),this.operation=super.token().text,super.nextToken(),super.addChild(super.evalUntil(null,!1,!1)),super.expectEnd()}doExecute(){if(!currantCompareTypes(super.childValue(0).type,super.childValue(1).type))throw new Error(`unable to do comparison - "${this.children[0].src}" and "${this.children[1].src}" do not have the same type`);if(!currantGetNumberTypes().includes(super.childValue(0).type.constructor))throw new Error(`unable to do comparison - "${this.children[0].src}" is not a number`);let e=!1;switch(this.operation){case"<":e=super.childValue(0).get()<super.childValue(1).get();break;case">":e=super.childValue(0).get()>super.childValue(1).get();break;case"<=":e=super.childValue(0).get()<=super.childValue(1).get();break;case">=":e=super.childValue(0).get()>=super.childValue(1).get()}return currantCreateBool(e)}}class CurrantEqualityNode extends CurrantNode{constructor(){super("equality")}doParse(){super.addChild(super.evalUntil(["double_equals","not_equals"],!1,!1)),this.operation=super.token().text,super.nextToken(),super.addChild(super.evalUntil(null,!1,!1)),super.expectEnd()}doExecute(){let e=!1;switch(this.operation){case"==":e=super.childValue(0).equals(super.childValue(1));break;case"!=":e=!super.childValue(0).equals(super.childValue(1))}return new currantCreateBool(e)}}class CurrantParenthesesNode extends CurrantNode{constructor(){super("parentheses")}doParse(){super.expectToken("opening_parenthesis"),super.nextToken(),super.addChild(super.evalUntil(["closing_parenthesis"],!1,!0)),super.expectToken("closing_parenthesis"),super.expectEnd()}doExecute(){return this.childValues[0]}}class CurrantGetType extends CurrantNode{constructor(){super("get-type")}doParse(){super.expectToken("hashtag"),super.nextToken(),super.addChild(super.evalUntil(null,!1,!1)),super.expectEnd()}doExecute(){return(new CurrantTypeType).fromValue(this.childValue(0).type)}}class CurrantInvalidValueError extends Error{constructor(){super("Invalid value for variable")}}class CurrantType{constructor(){if("function"!=typeof this.varStorage)throw new Error(`"${this.constructor.name}" does not implement 'varStorage(size)'`);if("function"!=typeof this.instNode)throw new Error(`"${this.constructor.name}" does not implement 'instNode(node)'`);if("function"!=typeof this.instVal)throw new Error(`"${this.constructor.name}" does not implement 'instVal(value)'`)}fromNode(e){let t=this.varStorage(1);return t[0]=this.instNode(e),new CurrantTypeInstance(this,t)}fromValue(e){let t=this.varStorage(1);return t[0]=this.instVal(e),new CurrantTypeInstance(this,t)}}class CurrantTypeInstance{constructor(e,t){this.type=e,this.value=t}get(){return this.value[0]}equals(e){return!!currantCompareTypes(this.type,e.type)&&("function"!=typeof this.type.eq?this.get()===e.get():this.type.eq(this.get(),e.get()))}getValue(){return"function"!=typeof this.type.val?this.get():this.type.val(this.get())}copy(){return"function"!=typeof this.type.copy?this.type.fromValue(this.value[0]):this.type.fromValue(this.type.copy(this.value[0]))}}class CurrantVariableReference{constructor(e,t){this.set=e,this.get=t}}class CurrantTypeType extends CurrantType{varStorage(e){return new Array(e)}instNode(e){return null}instVal(e){return e}eq(e,t){return currantCompareTypes(e,t)}}class CurrantU8Node extends CurrantLiteralNode{constructor(){super("u8-literal","u8_literal",CurrantU8Type)}}class CurrantU8Type extends CurrantType{varStorage(e){return new Uint8Array(e)}instNode(e){return Number(e.value.substring(0,e.value.length-2))}instVal(e){return e}}class CurrantU16Node extends CurrantLiteralNode{constructor(){super("u16-literal","u16_literal",CurrantU16Type)}}class CurrantU16Type extends CurrantType{varStorage(e){return new Uint16Array(e)}instNode(e){return Number(e.value.substring(0,e.value.length-3))}instVal(e){return e}}class CurrantU32Node extends CurrantLiteralNode{constructor(){super("u32-literal","u32_literal",CurrantU32Type)}}class CurrantU32Type extends CurrantType{varStorage(e){return new Uint32Array(e)}instNode(e){return Number(e.value.substring(0,e.value.length-3))}instVal(e){return e}}class CurrantU64Node extends CurrantLiteralNode{constructor(){super("u64-literal","u64_literal",CurrantU64Type)}}class CurrantU64Type extends CurrantType{varStorage(e){return new BigUint64Array(e)}instNode(e){return BigInt(e.value.substring(0,e.value.length-3))}instVal(e){return"bigint"==typeof e?e:BigInt(Math.floor(e))}}class CurrantI8Node extends CurrantLiteralNode{constructor(){super("i8-literal","i8_literal",CurrantI8Type)}}class CurrantI8Type extends CurrantType{varStorage(e){return new Int8Array(e)}instNode(e){return Number(e.value.substring(0,e.value.length-2))}instVal(e){return e}}class CurrantI16Node extends CurrantLiteralNode{constructor(){super("i16-literal","i16_literal",CurrantI16Type)}}class CurrantI16Type extends CurrantType{varStorage(e){return new Int16Array(e)}instNode(e){return Number(e.value.substring(0,e.value.length-3))}instVal(e){return e}}class CurrantI32Node extends CurrantLiteralNode{constructor(){super("i32-literal","i32_literal",CurrantI32Type)}}class CurrantI32Type extends CurrantType{varStorage(e){return new Int32Array(e)}instNode(e){return Number(e.value.substring(0,e.value.length-3))}instVal(e){return e}}class CurrantI64Node extends CurrantLiteralNode{constructor(){super("i64-literal","i64_literal",CurrantI64Type)}}class CurrantI64Type extends CurrantType{varStorage(e){return new BigInt64Array(e)}instNode(e){return BigInt(e.value.substring(0,e.value.length-3))}instVal(e){return"bigint"==typeof e?e:BigInt(Math.floor(e))}}class CurrantBooleanNode extends CurrantLiteralNode{constructor(){super("bool-literal","boolean_literal",CurrantBooleanType)}}class CurrantBooleanType extends CurrantType{varStorage(e){return new Array(e)}instNode(e){return"true"===e.value}instVal(e){return e}}class CurrantF32Node extends CurrantLiteralNode{constructor(){super("f32-literal","f32_literal",CurrantF32Type)}}class CurrantF32Type extends CurrantType{varStorage(e){return new Float32Array(e)}instNode(e){return Number(e.value.substring(0,e.value.length-3))}instVal(e){return e}}class CurrantF64Node extends CurrantLiteralNode{constructor(){super("f64-literal","f64_literal",CurrantF64Type)}}class CurrantF64Type extends CurrantType{varStorage(e){return new Float64Array(e)}instNode(e){return Number(e.value.substring(0,e.value.length-3))}instVal(e){return e}}class CurrantFunctionNode extends CurrantNode{constructor(){super("function")}doParse(){let e=!0;this.paramNames=[];let t=[];this.paramConstraintNodes=[];let r=null;if(this.isTypeConstructor=!1,"dollar"===super.token().name&&(this.isTypeConstructor=!0,super.nextToken()),"opening_parenthesis"===super.token().name){if(super.expectToken("opening_parenthesis"),super.nextToken(),"closing_parenthesis"!==super.token().name)for(;super.expectToken("identifier"),this.paramNames.push(super.token().text),super.nextToken(),super.expectToken("colon"),super.nextToken(),"question_mark"===super.token().name?(t.push(null),super.nextToken()):t.push(super.evalUntil(["comma","double_arrow_right","closing_parenthesis"],!1,!1)),"double_arrow_right"===super.token().name?(super.nextToken(),this.paramConstraintNodes.push(super.evalUntil(["comma","closing_parenthesis"],!1,!1))):this.paramConstraintNodes.push(null),"closing_parenthesis"!==super.token().name;)super.expectToken("comma"),super.nextToken();super.expectToken("closing_parenthesis"),super.nextToken(),"arrow_right"===super.token().name&&(super.nextToken(),r=super.evalUntil(["opening_brace"],!1,!1))}"arrow_left"===super.token().name&&(e=!1,super.nextToken()),super.expectToken("opening_brace"),super.nextToken();let n=[],a=1;for(;"opening_brace"===super.token().name&&a++,"closing_brace"===super.token().name&&a--,"closing_brace"!==super.token().name||0!==a;)n.push(super.token()),super.nextToken();super.addChild((new CurrantBlockNode).setReturnable(e).parse(n)),super.expectEnd(),this.returns=null!==r,this.returns&&super.addChild(r);for(const e of t)super.addChild(e)}prepareExecute(){this.executeChildren=!1}doExecute(){return this.isTypeConstructor?(new CurrantTypeType).fromValue(new CurrantCustomType(new CurrantFunction(this))):(new CurrantFunctionType).fromNode(this)}}class CurrantFunctionType extends CurrantType{varStorage(e){return new Array(e)}instNode(e){return new CurrantFunction(e)}instVal(e){return e}val(e){let t=function(...t){for(let e=0;e<t.length;e++){let r=t[e];if(r instanceof CurrantVariableReference&&(r=r.get()),!(r instanceof CurrantTypeInstance))throw new Error(`argument at index ${e} given to currant export function is not an instance of a currant type`)}let r=e.call(t);return r instanceof CurrantVariableReference&&(r=r.get()),r.getValue()};return t.ref=e,t}eq(e,t){return void 0!==e.ref&&void 0!==t.ref?e.ref===t.ref:void 0!==e.body&&void 0!==t.body&&(e.body.src===t.body.src&&e.body.file===t.body.file&&e.body.line===t.body.line)}}class CurrantFunctionInterface{constructor(){if("function"!=typeof this.call)throw new Error(`${this.constructor.name} does not implement 'call(parameters)'`)}}class CurrantFunction extends CurrantFunctionInterface{constructor(e){super(),this.file=e.file,this.line=e.line,this.body=e.children[0],this.returnType=null,this.lastCallBody=null;let t=1;e.returns&&(this.returnType=e.children[1],t=2),this.paramTypes=new Array(e.paramNames.length),this.paramConstraints=new Array(e.paramNames.length),this.paramNames=new Array(e.paramNames.length);for(let r=0;r<e.paramNames.length;r++)this.paramTypes[r]=e.children[t+r],this.paramConstraints[r]=e.paramConstraintNodes[r],this.paramNames[r]=e.paramNames[r]}call(e,t,r,n){if(e.length!==this.paramTypes.length)throw new Error(`function call expected ${this.paramTypes.length} parameter(s), got ${e.length} instead`);let a=this.body.copy(this.body.block);a.setAfterPrepare((()=>{for(let t=0;t<this.paramTypes.length;t++){let r=this.paramTypes[t],n=null;null!==r&&(r.setBlock(a),n=r.execute()),n instanceof CurrantVariableReference&&(n=n.get());let s=e[t];if(null!==n&&!currantCompareTypes(n.get(),s.type))throw new Error(`unable to call function - value for argument "${this.paramNames[t]}" (index ${t}) is not of type "${r.src}"`);let u=this.paramNames[t];a.createVariable(u,s.copy());let o=this.paramConstraints[t];if(null!==o){o.setBlock(a);let e=o.execute();if(e instanceof CurrantVariableReference&&(e=e.get()),!(e.type instanceof CurrantBooleanType))throw new Error(`unable to call function - defined constraint "${o.src}" for argument "${u}" (index ${t}) did not evaluate to a boolean`);if(e=e.get(),!0!==e)throw new Error(`unable to call function - defined constraint "${o.src}" for argument "${u}" (index ${t}) was not fulfilled (did not evaluate to true)`)}}}));let s=null;null==t&&(t="(unknown)"),null==r&&(r="(unknown)"),null==n&&(n="(unknown)"),a.currant.stack.push(t,r,n,this.file,this.line);let u=a.execute();if(this.lastCallBody=a,null!==this.returnType){if(this.returnType.setBlock(a),s=this.returnType.execute(),s instanceof CurrantVariableReference&&(s=s.get()),!currantCompareTypes(u.type,s.get()))throw new Error(`function did not return value of type "${this.returnType.src}"`)}else{let e=new CurrantNothingType;if(u.type.constructor!==e.constructor)throw new Error("function return expected nothing, got something instead");u=e.fromNode(null)}return a.currant.stack.pop(),u}}class CurrantJsFunction extends CurrantFunctionInterface{constructor(e){super(),this.ref=e}call(e){let t=new Array(e.length);for(let r=0;r<e.length;r++){let n=e[r];if((n instanceof CurrantVariableReference||n instanceof CurrantBlockVariableWrapperObject)&&(n=n.get()),!(n instanceof CurrantTypeInstance))throw new Error(`given argument at index ${r} has invalid type`);t[r]=n.getValue()}let r=this.ref(...t);return void 0===r&&(r=null),null===r?(new CurrantNothingType).fromNode(null):r}}class CurrantReturnNode extends CurrantNode{constructor(){super("return")}doParse(){if(this.hasReturnValue=!0,super.expectToken("arrow_right"),!super.hasNextToken())return super.expectEnd(),void(this.hasReturnValue=!1);super.nextToken(),super.addChild(super.evalUntil(null,!1,!1)),super.expectEnd()}doExecute(){this.hasReturnValue?this.block.returnValue(this.childValue(0)):this.block.returnValue(null)}}class CurrantFunctionCallNode extends CurrantNode{constructor(){super("function-call")}doParse(){if(super.addChild(super.evalUntilLastScopeOpen("opening_parenthesis","closing_parenthesis")),super.expectToken("opening_parenthesis"),super.nextToken(),"closing_parenthesis"!==super.token().name)for(;super.addChild(super.evalUntil(["closing_parenthesis","comma"],!1,!1)),"closing_parenthesis"!==super.token().name;)super.expectToken("comma"),super.nextToken();super.expectToken("closing_parenthesis"),super.expectEnd()}doExecute(){let e=this.childValue(0);if(!(e.get()instanceof CurrantFunctionInterface||e.get()instanceof CurrantCustomType))throw new Error(`unable to call function - "${this.children[0].src}" is not a function`);e=e.get();let t=new Array(this.children.length-1);for(let e=0;e<t.length;e++)t[e]=this.childValue(e+1);return e.call(t,this.children[0].src,this.block.currant.currentFile,this.block.currant.currentLine)}}class CurrantNothingType extends CurrantType{varStorage(e){return new Array(e)}instNode(e){return null}instVal(e){return e}val(e){return null}}class CurrantPointerNode extends CurrantNode{constructor(){super("pointer")}doParse(){super.expectToken("ampersand"),super.nextToken(),super.expectToken("identifier"),this.refName=super.token().text,super.expectEnd()}doExecute(){return this.ref=CurrantBlockNode.staticGetVariableWrapper(this.block.variables,this.block.block,this.refName),(new CurrantPointerType).fromNode(this)}}class CurrantMemberPointerNode extends CurrantNode{constructor(){super("member-pointer")}doParse(){super.addChild(super.evalUntilLast(["dot"],!0)),super.nextToken(),super.expectToken("ampersand"),super.nextToken(),super.expectToken("identifier"),this.refName=super.token().text,super.expectEnd()}doExecute(){let e=super.childValue(0);if(e.type.constructor!==CurrantCustomType)throw new Error(`unable to access member - object does not have member "${this.refName}"`);if(e=e.get(),!e.variables.has(this.refName))throw new Error(`unable to access member - object does not have member "${this.refName}"`);return this.ref=CurrantBlockNode.staticGetVariableWrapper(e.variables,e.block,this.refName),(new CurrantPointerType).fromNode(this)}}class CurrantPointerType extends CurrantType{varStorage(e){return new Array(e)}instNode(e){if(!(e.ref instanceof CurrantBlockVariableWrapperObject))throw new Error("tried to create a pointer to something that is not a variable");return new CurrantPointer(e.ref)}instVal(e){return e}val(e){return new CurrantPointer}eq(e,t){return e.ref===t.ref}}class CurrantPointer{constructor(e){void 0!==e&&(this.ref=e)}}class CurrantPointerDerefNode extends CurrantNode{constructor(){super("pointer-deref")}doParse(){super.expectToken("asterisk"),super.nextToken(),super.addChild(super.evalUntil(null,!1,!1)),super.expectEnd()}doExecute(){let e=super.childValue(0);if(e.type.constructor!==CurrantPointerType)throw new Error("tried to dereference something that is not a pointer");return new CurrantVariableReference((t=>{e.get().ref.value=t}),(()=>e.get().ref.value))}}class CurrantArrayNode extends CurrantNode{constructor(){super("array")}doParse(){if(this.dynSized=!1,super.expectToken("opening_bracket"),super.nextToken(),super.addChild(super.evalUntil(["colon","closing_bracket"],!1,!1)),super.hasNextToken())if(super.nextToken(),super.addChild(super.evalUntil(["colon","comma","closing_bracket"],!1,!1)),"colon"===super.token().name)this.dynSized=!0,super.nextToken(),super.addChild(super.evalUntil(["closing_bracket"],!1,!1));else if("comma"===super.token().name)for(super.nextToken();super.addChild(super.evalUntil(["comma","closing_bracket"],!1,!1)),"closing_bracket"!==super.token().name;)super.nextToken();super.expectToken("closing_bracket"),super.expectEnd()}doExecute(){if(this.itemType=super.childValue(0),!(this.itemType.get()instanceof CurrantType))throw new Error("unable to create array - specified type is not a type");if(this.values=[],this.dynSized){let e=super.childValue(1);if(e.type.constructor!==CurrantU64Type)throw new Error("unable to create array - specified length is not an unsigned 64-bit integer");for(let t=0;t<e.get();t++)this.values.push(super.childValue(2).copy())}else for(let e=1;e<this.children.length;e++)this.values.push(super.childValue(e).copy());for(let e=0;e<this.values.length;e++)if(!currantCompareTypes(this.values[e].type,this.itemType.get()))throw new Error(`unable to create array - type of element at index ${e} does not match array type`);return(new CurrantArrayType).fromNode(this)}}class CurrantArrayType extends CurrantType{varStorage(e){return new Array(e)}instNode(e){return new CurrantArray(e.itemType,e.values)}instVal(e){return e}val(e){let t=e.values.slice(0,e.values.length);for(let e=0;e<t.length;e++)t[e]=t[e].getValue();return t.ref=e,t}eq(e,t){if(!currantCompareTypes(e.itemType.get(),t.itemType.get()))return!1;if(e.values.length!==t.values.length)return!1;for(let r=0;r<e.values.length;r++)if(!e.values[r].equals(t.values[r]))return!1;return!0}copy(e){let t=new Array(e.values.length);for(let r=0;r<e.values.length;r++)t[r]=e.values[r].copy();return new CurrantArray(e.itemType,t)}}class CurrantArray{constructor(e,t){this.itemType=e,this.values=t}}class CurrantArrayAccessNode extends CurrantNode{constructor(){super("array-access")}doParse(){super.addChild(super.evalUntilLastScopeOpen("opening_bracket","closing_bracket")),super.nextToken(),super.addChild(super.evalUntil(["closing_bracket",!1,!1])),super.expectEnd()}doExecute(){let e=super.childValue(0);if(e.type.constructor!==CurrantArrayType)throw new Error("tried array access on something that is not an array");let t=super.childValue(1);if(t.type.constructor!==CurrantU64Type)throw new Error("tried array access using an index that is not an unsigned 64-bit integer.");if(t.get()>=e.get().values.length)throw new Error(`tried array access with out-of-bounds index (index ${t.get()} is out of bounds of length ${e.get().values.length})`);return new CurrantVariableReference((r=>{e.get().values[t.get()]=r}),(()=>e.get().values[t.get()]))}}class CurrantCustomType extends CurrantType{constructor(e){if(super(),this.constructorFunction=e,null!==this.constructorFunction.returnType)throw new Error("type constructor function has a return type");if(!this.constructorFunction.body.returnable)throw new Error("type constructor function has a passing return");this._checkReturnNodes(this.constructorFunction.body)}_checkReturnNodes(e){if(null!==e){if("return"===e.name&&null!==e.block){let t=e.block;for(;!t.returnable;)t=t.block;if(t===this.constructorFunction.body)throw new Error("return call in type constructor function (or a function defined inside of it) would result in early return of the constructor function")}for(const t of e.children)this._checkReturnNodes(t)}}varStorage(e){return new Array(e)}instNode(e){return null}instVal(e){return e}copy(e){return new CurrantCustomObject(e)}eq(e,t){for(const r of e.variables.keys()){if(!t.variables.has(r))return!1;if(!t.variables.get(r).get().equals(e.variables.get(r).get()))return!1}for(const r of t.variables.keys()){if(!e.variables.has(r))return!1;if(!e.variables.get(r).get().equals(t.variables.get(r).get()))return!1}return!0}val(e){let t={};for(const r of e.variables.keys()){let n=e.variables.get(r);void 0===n.upperBlockAccessName&&(t[r]=n.get().getValue())}return t}call(e,t,r,n){return this.constructorFunction.call(e,t,r,n),this.fromValue(new CurrantCustomObject(this.constructorFunction.lastCallBody))}}class CurrantCustomObject{constructor(e){this.funcBody=e instanceof CurrantCustomObject?e.funcBody.copy(e.funcBody.block):e,this.variables=this.funcBody.variables,this.block=this.funcBody.block}}class CurrantMemberAccessNode extends CurrantNode{constructor(){super("member-access")}doParse(){super.addChild(super.evalUntilLast(["dot"],!0)),super.nextToken(),super.expectToken("identifier"),this.member=super.token().text,super.expectEnd()}doExecute(){let e=super.childValue(0);if(e.type.constructor!==CurrantCustomType)throw new Error(`unable to access member - object does not have member "${this.member}"`);if(e=e.get(),!e.variables.has(this.member))throw new Error(`unable to access member - object does not have member "${this.member}"`);return CurrantBlockNode.staticGetVariableRef(e.variables,e.parentBlock,this.member)}}class CurrantStringNode extends CurrantLiteralNode{constructor(){super("string-literal","string_literal",CurrantStringType)}}class CurrantStringType extends CurrantType{varStorage(e){return new Array(e)}instNode(e){let t=e.value.substring(1,e.value.length-1),r=0;for(;r<t.length;)t.substr(r,2).startsWith("\\")&&(t=t.substr(r,2).startsWith("\\n")?t.substring(0,r)+"\n"+t.substring(r+2,t.length):t.substring(0,r)+t.substring(r+1,t.length),r++),r++;return t}instVal(e){return e}}const CURRANT_STD_TYPES="\n    type: t@CurrantTypeType = t@CurrantTypeType;\n    u8: type = t@CurrantU8Type;\n    u16: type = t@CurrantU16Type;\n    u32: type = t@CurrantU32Type;\n    u64: type = t@CurrantU64Type;\n    i8: type = t@CurrantI8Type;\n    i16: type = t@CurrantI16Type;\n    i32: type = t@CurrantI32Type;\n    i64: type = t@CurrantI64Type;\n    f32: type = t@CurrantF32Type;\n    f64: type = t@CurrantF64Type;\n    bool: type = t@CurrantBooleanType;\n    none: type = t@CurrantNothingType;\n    fun: type = t@CurrantFunctionType;\n    ptr: type = t@CurrantPointerType;\n    arr: type = t@CurrantArrayType;\n    str: type = t@CurrantStringType;\n",CURRANT_STD_CONSOLE="\n    log: fun = f@currantLog;\n    warn: fun = f@currantWarn;\n    panic: fun = f@currantPanic;\n";function currantLog(e){console.log(currantToString(e).get())}function currantWarn(e){console.warn(currantToString(e).get())}function currantPanic(e){throw new Error(currantToString(e).get())}const CURRANT_STD_CONDITIONS="\n    if: fun = f@currantIf;\n";function currantIf(e,t,r){if("boolean"!=typeof e)throw new Error("given argument at index 0 is not a boolean");if("function"!=typeof t)throw new Error("given argument at index 1 is not a function");if(void 0!==r&&"function"!=typeof r)throw new Error("given argument at index 2 is not a function / undefined");!0===e&&t(),!1===e&&"function"==typeof r&&r()}const CURRANT_STD_MATH="\n\n    len: fun = f@currantLen;\n\n    MathFunctionsType: type = $() {\n\n        E: f64 = 2.718281828459045f64;\n        PI: f64 = 3.141592653589793f64;\n\n        INT_8_MIN: i8 = -128i8;\n        INT_8_MAX: i8 = 127i8;\n        INT_16_MIN: i16 = -32768i16;\n        INT_16_MAX: i16 = 32767i16;\n        INT_32_MIN: i32 = -2147483648i32;\n        INT_32_MAX: i32 = 2147483647i32;\n        INT_64_MIN: i64 = -9223372036854775808i64;\n        INT_64_MAX: i64 = 9223372036854775807i64;\n\n        UINT_8_MIN: u8 = 0u8;\n        UINT_8_MAX: u8 = 255u8;\n        UINT_16_MIN: u16 = 0u16;\n        UINT_16_MAX: u16 = 65535u16;\n        UINT_32_MIN: u32 = 0u32;\n        UINT_32_MAX: u32 = 4294967295u32;\n        UINT_64_MIN: u64 = 0u64;\n        UINT_64_MAX: u64 = 18446744073709551615u64;\n\n        F32_INF: f32 = 1f32 / 0f32;\n        F32_NEG_INF: f32 = 0f32 - 1f32 / 0f32;\n        F64_INF: f64 = 1f64 / 0f64;\n        F64_NEG_INF: f64 = 0f64 - 1f64 / 0f64;\n\n        F32_NaN: f32 = f@currantGetNaNF32();\n        F64_NaN: f64 = f@currantGetNaNF64();\n\n        NUM_TYPES: arr = [type: f32, f64, i8, i16, i32, i64, u8, u16, u32, u64];\n\n        isNum: fun = (x: ?) -> bool {\n            if(#x == f32, <- { -> true });\n            if(#x == f64, <- { -> true });\n            if(#x == i8, <- { -> true });\n            if(#x == i16, <- { -> true });\n            if(#x == i32, <- { -> true });\n            if(#x == i64, <- { -> true });\n            if(#x == u8, <- { -> true });\n            if(#x == u16, <- { -> true });\n            if(#x == u32, <- { -> true });\n            if(#x == u64, <- { -> true });\n            -> false;\n        };\n\n        isNaNJsImpl: fun = f@currantIsNaN;\n        isNaN: fun = (x: ? => #x == f32 || #x == f64) -> bool {\n            -> isNaNJsImpl(x);\n        };\n\n        abs: fun = (x: ? => isNum(x)) -> #x {\n            if(x < #x~0u8, <- {\n                -> #x~0u8 - x;\n            });\n            -> x;\n        };\n\n        min: fun = (a: ? => isNum(a), b: #a) -> #a {\n            if(a < b, <- { -> a; });\n            -> b;\n        };\n\n        max: fun = (a: ? => isNum(a), b: #a) -> #a {\n            if(a > b, <- { -> a; });\n            -> b;\n        };\n\n        powJsImpl: fun = f@currantPow;\n        pow: fun = (x: ? => isNum(x), n: #x) -> #x {\n            -> powJsImpl(#x, x, n);\n        };\n\n        sqrtJsImpl: fun = f@currantSqrt;\n        sqrt: fun = (x: ? => isNum(x)) -> #x {\n            -> sqrtJsImpl(#x, x);\n        };\n\n        randomJsImpl: fun = f@currantRandom;\n        random: fun = () -> f64 {\n            -> randomJsImpl();\n        };\n\n        roundJsImpl: fun = f@currantRound;\n        round: fun = (x: ? => isNum(x)) -> #x {\n            -> roundJsImpl(#x, x);\n        };\n\n        cbrtJsImpl: fun = f@currantCbrt;\n        cbrt: fun = (x: ? => isNum(x)) -> #x {\n            -> cbrtJsImpl(#x, x);\n        };\n\n        ceilJsImpl: fun = f@currantCeil;\n        ceil: fun = (x: ? => isNum(x)) -> #x {\n            -> ceilJsImpl(#x, x);\n        };\n\n        floorJsImpl: fun = f@currantFloor;\n        floor: fun = (x: ? => isNum(x)) -> #x {\n            -> floorJsImpl(#x, x);\n        };\n\n        logJsImpl: fun = f@currantMathLog;\n        log: fun = (x: ? => isNum(x)) -> #x {\n            -> logJsImpl(#x, x);\n        };\n\n        log10JsImpl: fun = f@currantLog10;\n        log10: fun = (x: ? => isNum(x)) -> #x {\n            -> log10JsImpl(#x, x);\n        };\n\n        log1pJsImpl: fun = f@currantLog1p;\n        log1p: fun = (x: ? => isNum(x)) -> #x {\n            -> log1pJsImpl(#x, x);\n        };\n\n        expJsImpl: fun = f@currantExp;\n        exp: fun = (x: ? => isNum(x)) -> #x {\n            -> expJsImpl(#x, x);\n        };\n\n        expm1JsImpl: fun = f@currantExpm1;\n        expm1: fun = (x: ? => isNum(x)) -> #x {\n            -> expm1JsImpl(#x, x);\n        };\n\n        sinJsImpl: fun = f@currantSin;\n        sin: fun = (x: ? => isNum(x)) -> #x {\n            -> sinJsImpl(#x, x);\n        };\n\n        cosJsImpl: fun = f@currantCos;\n        cos: fun = (x: ? => isNum(x)) -> #x {\n            -> cosJsImpl(#x, x);\n        };\n\n        tanJsImpl: fun = f@currantTan;\n        tan: fun = (x: ? => isNum(x)) -> #x {\n            -> tanJsImpl(#x, x);\n        };\n\n        asinJsImpl: fun = f@currantAsin;\n        asin: fun = (x: ? => isNum(x)) -> #x {\n            -> asinJsImpl(#x, x);\n        };\n\n        acosJsImpl: fun = f@currantAcos;\n        acos: fun = (x: ? => isNum(x)) -> #x {\n            -> acosJsImpl(#x, x);\n        };\n\n        atanJsImpl: fun = f@currantAtan;\n        atan: fun = (x: ? => isNum(x)) -> #x {\n            -> atanJsImpl(#x, x);\n        };\n\n        sinhJsImpl: fun = f@currantSinh;\n        sinh: fun = (x: ? => isNum(x)) -> #x {\n            -> sinhJsImpl(#x, x);\n        };\n\n        coshJsImpl: fun = f@currantCosh;\n        cosh: fun = (x: ? => isNum(x)) -> #x {\n            -> coshJsImpl(#x, x);\n        };\n\n        tanhJsImpl: fun = f@currantTanh;\n        tanh: fun = (x: ? => isNum(x)) -> #x {\n            -> tanhJsImpl(#x, x);\n        };\n\n        toRadians: fun = (x: ? => isNum(x)) -> #x {\n            -> #x~(f64~x * Math.PI / 180f64);\n        };\n        radians: fun = toRadians;\n        rad: fun = toRadians;\n\n        toDegrees: fun = (x: ? => isNum(x)) -> #x {\n            -> #x~(f64~x * 180f64 / Math.PI);\n        };\n        degrees: fun = toDegrees;\n        deg: fun = toDegrees;\n\n    };\n    Math: MathFunctionsType = MathFunctionsType();\n\n";function currantGetNaNF32(){return currantCreateF32(NaN)}function currantGetNaNF64(){return currantCreateF64(NaN)}function currantIsNaN(e){return currantCreateBool(isNaN(e))}function currantLen(e){if(void 0===e.length)throw new Error("parameter at index 0 is not an array or string");return currantCreateU64(e.length)}function currantMathFunNumCheck(e){for(let t=0;t<e.length;t++)if("number"!=typeof e[t]&&"bigint"!=typeof e[t])throw new Error(`parameter at index ${t} is not a number`)}function currantPow(e,t,r){return currantMathFunNumCheck([t,r]),e.fromValue(Math.pow(Number(t),Number(r)))}function currantSqrt(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.sqrt(Number(t)))}function currantRandom(){return currantCreateF64(Math.random())}function currantRound(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.round(Number(t)))}function currantCbrt(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.cbrt(Number(t)))}function currantCeil(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.ceil(Number(t)))}function currantFloor(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.floor(Number(t)))}function currantMathLog(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.log(Number(t)))}function currantLog10(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.log10(Number(t)))}function currantLog1p(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.log1p(Number(t)))}function currantExp(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.exp(Number(t)))}function currantExpm1(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.expm1(Number(t)))}function currantSin(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.sin(Number(t)))}function currantCos(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.cos(Number(t)))}function currantTan(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.tan(Number(t)))}function currantAsin(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.asin(Number(t)))}function currantAcos(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.acos(Number(t)))}function currantAtan(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.atan(Number(t)))}function currantSinh(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.sinh(Number(t)))}function currantCosh(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.cosh(Number(t)))}function currantTanh(e,t){return currantMathFunNumCheck([t]),e.fromValue(Math.tanh(Number(t)))}const CURRANT_STD_LOOPS="\n    lpa: type = u8;\n    cont: lpa = 0u8;\n    brk: lpa = 1u8;\n    loop: fun = f@currantLoop;\n\n    while: fun = (doExecute: fun, loopBody: fun) {\n        loop(() -> lpa {\n            if(!doExecute(), <- {\n                -> brk;\n            });\n            -> loopBody();\n        });\n    };\n\n    range: fun = (start: u64, end: u64) -> arr {\n        rangeLength: u64 = Math.max(start, end) - Math.min(start, end);\n        rangeArray: arr = [u64: rangeLength: 0u64];\n        i: u64 = 0u64;\n        while(() -> bool { -> i < rangeLength; }, () -> lpa {\n            if(start < end, { rangeArray[i] = start + i; });\n            if(start > end, { rangeArray[i] = start - i; });\n            i = i + 1u64;\n            -> cont;\n        });\n        -> rangeArray;\n    };\n\n    for: fun = (array: arr, loopBody: fun) {\n        i: u64 = 0u64;\n        while(() -> bool { -> i < len(array); }, () -> lpa {\n            cAction: lpa = loopBody(array[i]);\n            i = i + 1u64;\n            -> cAction;\n        });\n    };\n";function currantLoop(e){if("function"!=typeof e)throw new Error("given argument at index 0 is not a function");for(;;){let t=e();if(0!==t&&1!==t)throw new Error("loop body did not return continue ('cont') or break ('brk')");if(1===t)break}}const CURRANT_STD_BOXES='\n\n    Box: type = $(val: ?) {\n\n        getType: fun = () -> type {\n            -> #val;\n        };\n\n        isSome: fun = () -> bool {\n            -> getType() != none;\n        };\n\n        isNone: fun = () -> bool {\n            -> getType() == none;\n        };\n\n        unwrap: fun = () -> #val {\n            if(isNone(), { panic("Unwrapped a None-Box"); });\n            -> val;\n        };\n\n        expect: fun = (message: str) -> #val {\n            if(isNone(), { panic(message); });\n            -> val;\n        };\n\n    };\n\n    NoneBox: fun = () -> Box {\n        -> Box({}());\n    };\n\n',CURRANT_STD_STRINGS='\n\n    StringFunctionsType: type = $() {\n\n        toString: fun = f@currantToString;\n\n        containsNum: fun = f@currantContainsNum;\n\n        parseNumJsImpl: fun = f@currantParseNum;\n        parseNum: fun = (numType: type, string: str) -> Box {\n            if(!containsNum(string), <- {\n                -> NoneBox();\n            });\n            -> Box(parseNumJsImpl(numType, string));\n        };\n\n        subStrJsImpl: fun = f@currantSubstr;\n        subStr: fun = (string: str, start: u64, end: u64) -> str {\n            if(start > end, {\n                panic("start index (" + toString(start) + ") is greater than end index (" + toString(end) + ")");\n            });\n            if(end > len(string), {\n                panic("end index (" + toString(end) + ") is out of bounds for string (length " + toString(len(string)) + ")");\n            });\n            -> subStrJsImpl(string, start, end);\n        };\n\n        startsWithJsImpl: fun = f@currantStartsWith;\n        startsWith: fun = (string: str, prefix: str) -> bool {\n            -> startsWithJsImpl(string, prefix);\n        };\n\n        endsWithJsImpl: fun = f@currantEndsWith;\n        endsWith: fun = (string: str, suffix: str) -> bool {\n            -> endsWithJsImpl(string, suffix);\n        };\n\n        containsJsImpl: fun = f@currantStrContains;\n        contains: fun = (string: str, part: str) -> bool {\n            -> containsJsImpl(string, part);\n        };\n\n        indexOfJsImpl: fun = f@currantStrIndexOf;\n        indexOf: fun = (string: str, part: str) -> Box {\n            if(!contains(string, part), <- { -> NoneBox(); });\n            -> Box(indexOfJsImpl(string, part));\n        };\n\n        lastIndexOfJsImpl: fun = f@currantStrLastIndexOf;\n        lastIndexOf: fun = (string: str, part: str) -> Box {\n            if(!contains(string, part), <- { -> NoneBox(); });\n            -> Box(lastIndexOfJsImpl(string, part));\n        };\n\n        toUpperJsImpl: fun = f@currantToUpper;\n        toUpper: fun = (string: str) -> str {\n            -> toUpperJsImpl(string);\n        };\n\n        toLowerJsImpl: fun = f@currantToLower;\n        toLower: fun = (string: str) -> str {\n            -> toLowerJsImpl(string);\n        };\n\n        trimJsImpl: fun = f@currantTrim;\n        trim: fun = (string: str) -> str {\n            -> trimJsImpl(string);\n        };\n\n    };\n    String: StringFunctionsType = StringFunctionsType();\n\n';function currantToString(e){return null===e?currantCreateStr("[none]"):e instanceof CurrantPointer?currantCreateStr("[pointer]"):e instanceof CurrantType?currantCreateStr("[type]"):e instanceof Array?currantArrayToString(e):currantCreateStr("function"==typeof e?"[function]":"object"==typeof e?"[object]":String(e))}function currantArrayToString(e){let t="[array: ";for(const r of e)t+=currantToString(r).get()+", ";return currantCreateStr(t.substring(0,t.length-2)+"]")}function currantContainsNum(e){return 0===e.length?currantCreateBool(!1):currantCreateBool(!isNaN(e))}function currantParseNum(e,t){return e.fromValue(t)}function currantSubstr(e,t,r){return currantCreateStr(e.substring(Number(t),Number(r)))}function currantStartsWith(e,t){return currantCreateBool(e.startsWith(t))}function currantEndsWith(e,t){return currantCreateBool(e.endsWith(t))}function currantStrContains(e,t){return currantCreateBool(e.includes(t))}function currantStrIndexOf(e,t){return currantCreateU64(e.indexOf(t))}function currantStrLastIndexOf(e,t){return currantCreateU64(e.lastIndexOf(t))}function currantToUpper(e){return currantCreateStr(e.toUpperCase())}function currantToLower(e){return currantCreateStr(e.toLowerCase())}function currantTrim(e){return currantCreateStr(e.trim())}const CURRANT_STD_TIME="\n\n    TimeFunctionsType: type = $() {\n\n        millis: fun = f@currantTimeMillis;\n\n        seconds: fun = f@currantTimeSeconds;\n\n        sleepJsImpl: fun = f@currantSleep;\n        sleepAsync: fun = (action: fun, timeout: u64) {\n            sleepJsImpl(action, timeout);\n        };\n\n    };\n    Time: TimeFunctionsType = TimeFunctionsType();\n\n";function currantTimeMillis(){return currantCreateU64(Date.now())}function currantTimeSeconds(){return currantCreateU64(Math.floor(Date.now()/1e3))}function currantSleep(e,t){setTimeout(e,Number(t))}const CURRANT_STD_ARRAYS='\n\n    ArrayFunctionsType: type = $() {\n\n        itemType: fun = f@currantArrayItemType;\n\n        reverse: fun = (src: arr) -> arr {\n            if(len(src) == 0u64, <- { -> [itemType(src): 0u64: none]; });\n            dest: arr = [itemType(src): len(src): src[0u64]];\n            for(range(0u64, len(src)), (i: u64) -> lpa {\n                dest[len(src) - 1u64 - i] = src[i];\n                -> cont;\n            });\n            -> dest;\n        };\n        rev: fun = reverse;\n\n        copyRange: fun = (src: arr, start: u64, end: u64) -> arr {\n            destLength: u64 = Math.max(start, end) - Math.min(start, end);\n            if(destLength == 0u64, <- { -> [itemType(src): 0u64: 0u8]; });\n            dest: arr = [itemType(src): destLength: src[0u64]];\n            destIndex: u64 = 0u64;\n            for(range(start, end), (srcIndex: u64) -> lpa {\n                dest[destIndex] = src[srcIndex];\n                destIndex = destIndex + 1u64;\n                -> cont;\n            });\n            -> dest;\n        };\n\n        copyIntoPtr: fun = (src: arr, srcStart: u64, dest: ptr, destStart: u64, elements: u64) {\n            for(range(0u64, elements), (i: u64) -> lpa {\n                *dest[destStart + i] = src[srcStart + i];\n                -> cont;\n            });\n        };\n\n        copyIntoCopy: fun = (src: arr, srcStart: u64, dest: arr, destStart: u64, elements: u64) -> arr {\n            copyIntoPtr(src, srcStart, &dest, destStart, elements);\n            -> dest;\n        };\n\n        addAt: fun = (src: arr, index: u64, item: itemType(src)) -> arr {\n            dest: arr = [itemType(src): len(src) + 1u64: item];\n            copyIntoPtr(src, 0u64, &dest, 0u64, index);\n            dest[index] = item;\n            copyIntoPtr(src, index, &dest, index + 1u64, len(src) - index);\n            -> dest;\n        };\n\n        add: fun = (src: arr, item: itemType(src)) -> arr {\n            -> addAt(src, len(src), item);\n        };\n\n        append: fun = (src: arr, items: arr) -> arr {\n            if(itemType(src) != itemType(items), { panic("item types of the given arrays do not match"); });\n            if(len(src) == 0u64, <- { -> items; });\n            if(len(items) == 0u64, <- { -> src; });\n            dest: arr = [itemType(src): len(src) + len(items): src[0u64]];\n            copyIntoPtr(src, 0u64, &dest, 0u64, len(src));\n            copyIntoPtr(items, 0u64, &dest, len(src), len(items));\n            -> dest;\n        };\n\n        indexOf: fun = (src: arr, item: itemType(src)) -> Box {\n            result: Box = NoneBox();\n            for(reverse(range(0u64, len(src))), (i: u64) -> lpa {\n                if(src[i] == item, { result = Box(i); });\n                -> cont;\n            });\n            -> result;\n        };\n\n        lastIndexOf: fun = (src: arr, item: itemType(src)) -> Box {\n            result: Box = NoneBox();\n            for(range(0u64, len(src)), (i: u64) -> lpa {\n                if(src[i] == item, { result = Box(i); });\n                -> cont;\n            });\n            -> result;\n        };\n\n        contains: fun = (src: arr, item: itemType(src)) -> bool {\n            -> indexOf(src, item).isSome();\n        };\n\n        containsAll: fun = (src: arr, items: arr) -> bool {\n            if(itemType(src) != itemType(items), { panic("item types of the given arrays do not match"); });\n            if(len(items) == 0u64, <- { -> true; });\n            if(len(src) == 0u64, <- { -> false; });\n            notFound: bool = false;\n            for(items, (item: itemType(items)) -> lpa {\n                if(!contains(src, item), <- {\n                    notFound = true;\n                    -> brk;\n                });\n                -> cont;\n            });\n            -> !notFound;\n        };\n\n        removeAt: fun = (src: arr, index: u64) -> arr {\n            if(len(src) == 0u64, { panic("given array is already empty"); });\n            dest: arr = [itemType(src): len(src) - 1u64: src[0u64]];\n            copyIntoPtr(src, 0u64, &dest, 0u64, index);\n            copyIntoPtr(src, index + 1u64, &dest, index, len(dest) - index);\n            -> dest;\n        };\n\n        remove: fun = (src: arr, item: itemType(src)) -> arr {\n            removalIndex: Box = indexOf(src, item);\n            if(removalIndex.isNone(), <- { -> src; });\n            -> removeAt(src, removalIndex.unwrap());\n        };\n\n        removeLast: fun = (src: arr, item: itemType(src)) -> arr {\n            removalIndex: Box = lastIndexOf(src, item);\n            if(removalIndex.isNone(), <- { -> src; });\n            -> removeAt(src, removalIndex.unwrap());\n        };\n\n    };\n    Array: ArrayFunctionsType = ArrayFunctionsType();\n\n';function currantArrayItemType(e){if(void 0===e.ref||!(e.ref instanceof CurrantArray))throw new Error("parameter at index 0 is not an array");return e.ref.itemType}const CURRANT_STD_DATASTRUCTURES="\n\n    HshMap: type = $(keyType: type, valType: type) {\n\n        loadFactor: f32 = 0.75f32;\n\n        setLoadFactor: fun = (newLoadFactor: f32) {\n            loadFactor = newLoadFactor;\n        };\n\n        setInitialCapacity: fun = (newInitialCapacity: u64 => newInitialCapacity > 0u64) {\n            if(size() != 0u64, <- { ->; });\n            buckets = [arr: newInitialCapacity: [Item: 0u64: none]];\n        };\n\n        getKeyType: fun = () -> type { -> keyType; };\n\n        getValType: fun = () -> type { -> valType; };\n\n        Item: type = $(key: keyType, value: valType) {};\n\n        buckets: arr = [arr: 16u64: [Item: 0u64: none]];\n        itemCount: u64 = 0u64;\n\n        getBucketIndex: fun = (key: keyType) -> u64 {\n            -> getKeyHash(key) % len(buckets);\n        };\n\n        getHashJsImpl: fun = f@currantGetHash;\n        getKeyHash: fun = (key: keyType) -> u64 {\n            -> u64~getHashJsImpl(key);\n        };\n\n        keys: fun = () -> arr {\n            r: arr = [keyType: 0u64: none];\n            for(buckets, (bucket: arr) -> lpa {\n                for(bucket, (item: Item) -> lpa {\n                    r = Array.add(r, item.key);\n                    -> cont;\n                });\n                -> cont;\n            });\n            -> r;\n        };\n\n        values: fun = () -> arr {\n            r: arr = [valType: 0u64: none];\n            for(buckets, (bucket: arr) -> lpa {\n                for(bucket, (item: Item) -> lpa {\n                    r = Array.add(r, item.value);\n                    -> cont;\n                });\n                -> cont;\n            });\n            -> r;\n        };\n\n        containsKey: fun = (key: keyType) -> bool {\n            bucketIndex: u64 = getBucketIndex(key);\n            found: bool = false;\n            for(buckets[bucketIndex], (item: Item) -> lpa {\n                if(item.key == key, <- {\n                    found = true;\n                    -> brk;\n                });\n                -> cont;\n            });\n            -> found;\n        };\n\n        containsValue: fun = (value: valType) -> bool {\n            -> Array.contains(values(), value);\n        };\n\n        size: fun = () -> u64 {\n            -> itemCount;\n        };\n\n        isEmpty: fun = () -> bool {\n            -> itemCount == 0u64;\n        };\n\n        put: fun = (key: keyType, value: valType) {\n            bucketIndex: u64 = getBucketIndex(key);\n            found: bool = false;\n            for(buckets[bucketIndex], (item: Item) -> lpa {\n                if(item.key == key, <- {\n                    item.value = value;\n                    found = true;\n                    -> brk;\n                });\n                -> cont;\n            });\n            if(!found, {\n                buckets[bucketIndex] = Array.add(buckets[bucketIndex], Item(key, value));\n                itemCount = itemCount + 1u64;\n                if(size() > u64~(f64~len(buckets) * f64~loadFactor), {\n                    oldBuckets: arr = buckets;\n                    buckets = [arr: len(buckets) * 2u64: [Item: 0u64: none]];\n                    for(oldBuckets, (bucket: arr) -> lpa {\n                        for(bucket, (item: Item) -> lpa {\n                            bucketIndex: u64 = getBucketIndex(item.key);\n                            buckets[bucketIndex] = Array.add(buckets[bucketIndex], item);\n                            -> cont;\n                        });\n                        -> cont;\n                    });\n                });\n            });\n        };\n\n        get: fun = (key: keyType) -> Box {\n            bucketIndex: u64 = getBucketIndex(key);\n            foundBox: Box = NoneBox();\n            for(buckets[bucketIndex], (item: Item) -> lpa {\n                if(item.key == key, <- {\n                    foundBox = Box(item.value);\n                    -> brk;\n                });\n                -> cont;\n            });\n            -> foundBox;\n        };\n\n        getOrDefault: fun = (key: keyType, defaultValue: valType) -> valType {\n            r: Box = get(key);\n            if(r.isSome(), <- { -> r.unwrap(); });\n            -> defaultValue;\n        };\n\n        remove: fun = (key: keyType) {\n            bucketIndex: u64 = getBucketIndex(key);\n            itemIndex: Box = NoneBox();\n            for(range(0u64, len(buckets[bucketIndex])), (i: u64) -> lpa {\n                if(buckets[bucketIndex][i].key == key, <- {\n                    itemIndex = Box(i);\n                    -> brk;\n                });\n                -> cont;\n            });\n            if(itemIndex.isNone(), <- { ->; });\n            buckets[bucketIndex] = Array.removeAt(buckets[bucketIndex], itemIndex.unwrap());\n            itemCount = itemCount - 1u64;\n        };\n\n    };\n\n";function currantGetHash(e){let t,r,n=JSON.stringify(e),a=0;if(0===n.length)return a;for(t=0;t<n.length;t++)r=n.charCodeAt(t),a=(a<<5)-a+r,a|=0;return currantCreateU32(a)}const CURRANT_STD_TESTING='\n    assert: fun = (statement: bool) {\n        if(!statement, {\n            panic("assertion failed");\n        });\n    };\n',CURRANT_STD_MACROS="\n\n    #start-macro \\|(.+?)\\|\n    () -> #macro_operation_result {\n        macro_operation_result: ? = {0};\n        -> macro_operation_result;\n    }\n    #end-macro\n\n    #start-macro \\^\n    <-\n    #end-macro\n\n";class CurrantStack{constructor(){this.elements=[]}produceStackTrace(e,t,r){null===e&&(e="(unknown)"),null===t&&(t="(unknown)");let n=`Script "${e}" panicked on line ${t}: ${r}`;for(const e of this.elements.slice(0,this.elements.length).reverse())n+=`\n    called "${e.callRef}" - called from "${e.callFile}" on line ${e.callLine} - defined in "${e.srcFile}" on line ${e.srcLine}`;return n}push(e,t,r,n,a){null===t&&(t="(unknown)"),null===r&&(r="(unknown)"),null===n&&(n="(unknown)"),null===a&&(a="(unknown)"),this.elements.push({callRef:e,callFile:t,callLine:r,srcFile:n,srcLine:a})}pop(){this.elements.pop()}clear(){this.elements=[]}}class CurrantScriptLoader{constructor(){this.queue=[],this.running=!1}execute(){if(0!==this.queue.length&&!this.running)if(this.running=!0,currant.currentLine=0,void 0!==this.queue[0].file){currant.currentFile=this.queue[0].file;fetch(this.queue[0].file).then((e=>{if(200===e.status)return e.text();throw new Error(`[${e.status}] ${e.statusText}`)})).then((e=>{this.queue[0].test?currant.test(e,this.queue[0].file):currant.run(e,this.queue[0].file)})).catch((e=>{currant.handleError(e)})).finally((()=>{this.finishExecute()}))}else currant.currentFile="(html tag)",this.queue[0].test?currant.test(this.queue[0].text,"(html tag)"):currant.run(this.queue[0].text,"(html tag)"),this.finishExecute()}finishExecute(){this.running=!1,this.queue.shift(),this.execute()}queueFile(e,t){this.queue.push({file:e,test:t}),this.execute()}queueText(e,t){this.queue.push({text:e,test:t}),this.execute()}}class Currant{constructor(){this.preprocessor=new CurrantPreprocessor,this.lexer=new CurrantLexer,this.lastBlockNode=null,this.currentFile=null,this.currentLine=0,this.scriptTagName="currant-script",this.showInterpreterStackTrace=!1,this.printPreprocessorOutput=!1,this.stack=new CurrantStack,this.loader=new CurrantScriptLoader,this._loadDefaults()}_loadDefaults(){this.run(CURRANT_STD_TYPES,"std.types.crn"),this.run(CURRANT_STD_CONSOLE,"std.console.crn"),this.run(CURRANT_STD_CONDITIONS,"std.conditions.crn"),this.run(CURRANT_STD_MATH,"std.math.crn"),this.run(CURRANT_STD_LOOPS,"std.loops.crn"),this.run(CURRANT_STD_BOXES,"std.boxes.crn"),this.run(CURRANT_STD_STRINGS,"std.strings.crn"),this.run(CURRANT_STD_TIME,"std.time.crn"),this.run(CURRANT_STD_ARRAYS,"std.arrays.crn"),this.run(CURRANT_STD_DATASTRUCTURES,"std.data_structures.crn"),this.run(CURRANT_STD_TESTING,"std.testing.crn"),this.run(CURRANT_STD_MACROS,"std.macros.crn")}showInternalStackTrace(e){this.showInterpreterStackTrace=!0===e}showPreprocessorOutput(e){this.printPreprocessorOutput=!0===e}handleError(e){throw this.showInterpreterStackTrace?(console.error(this.stack.produceStackTrace(this.currentFile,this.currentLine,e.message)),e):new Error(this.stack.produceStackTrace(this.currentFile,this.currentLine,e.message))}_runInternal(e,t){this.stack.clear(),void 0===t&&(t=null);let r=this.preprocessor.process(e);!0===this.printPreprocessorOutput&&(console.info('Processing of Macros for script "'+t+'" produced the following output:'),console.info(r));let n=this.lexer.tokenize(r,t);for(const e of n)e.currant=this;let a=(new CurrantBlockNode).setRuntime(this).parse(n);a.block=this.lastBlockNode;let s=a.execute();return this.lastBlockNode=a,null===s?s:s.getValue()}run(e,t){try{return this._runInternal(e,t)}catch(e){this.handleError(e)}}test(e,t){let r;try{r=this._runInternal(e,t)}catch(e){return console.error(`Test "${t}" failed:`),void this.handleError(e)}return console.log(`%cTest "${t}" passed!`,"color: #84da72;"),r}}const currant=new Currant;class CurrantScript extends HTMLElement{constructor(){super(),addEventListener("load",(e=>{this.style="display: none; white-space: pre-wrap;",this.type="text/plain";let t="script";this.hasAttribute("type")&&(t=this.getAttribute("type")),"script"!==t&&"test"!==t&&(console.warn(`'${currant.scriptTagName}'-element specified invalid attribute 'type', must be "script" or "test", but is "${t}" instead. Defaulting to "script".`),t="script"),this.hasAttribute("src")&&currant.loader.queueFile(this.getAttribute("src"),"test"===t);let r=this.innerHTML.split("&amp;").join("&").split("&lt;").join("<").split("&gt;").join(">");0!==r.trim().length&&currant.loader.queueText(r,"test"===t)}))}}customElements.define(currant.scriptTagName,CurrantScript);